import type { Database } from "@acme/db/client";
import { Workout, WorkoutExercise } from "@acme/db/schema";
import { 
  transformLLMOutputToDB, 
  validateExerciseLookup,
  type LLMWorkoutOutput 
} from "@acme/ai";
import { createLogger } from "../utils/logger";

const logger = createLogger('LLMWorkoutService');

export interface SaveWorkoutInput {
  trainingSessionId: string;
  userId: string;
  businessId: string;
  createdByTrainerId: string;
  llmOutput: LLMWorkoutOutput;
  workoutType?: string;
  workoutName?: string;
  workoutDescription?: string;
}

export interface TransformedWorkout {
  workout: {
    description: string;
    workoutType: string;
    totalPlannedSets: number;
    llmOutput: any;
    templateConfig: any;
  };
  exercises: Array<{
    exerciseId: string;
    orderIndex: number;
    sets: number;
    groupName?: string;
    reps?: string;
    restPeriod?: string;
    notes?: string;
  }>;
}

export class LLMWorkoutService {
  constructor(private db: Database) {}

  /**
   * Create exercise lookup map from all exercises
   */
  async createExerciseLookup(): Promise<Map<string, any>> {
    const allExercises = await this.db.query.exercises.findMany();
    if (!allExercises) {
      logger.warn('No exercises found in database');
      return new Map();
    }
    return new Map(allExercises.map(ex => [ex.id, ex]));
  }

  /**
   * Save individual workout (no training session)
   */
  async saveIndividualWorkout(
    input: Omit<SaveWorkoutInput, 'trainingSessionId'> & { 
      templateType: string;
      context?: string;
    },
    clientName?: string
  ) {
    // Create exercise lookup
    const exerciseLookup = await this.createExerciseLookup();
    
    // Validate exercises in LLM output
    this.validateLLMOutput(input.llmOutput, exerciseLookup);
    
    // Transform LLM output to database format
    const transformed = await this.transformOutput(
      input.llmOutput,
      exerciseLookup,
      input.templateType,
      input.workoutName,
      input.workoutDescription,
      clientName
    );
    
    // Use transaction to create workout and exercises atomically
    const result = await this.db.transaction(async (tx) => {
      // Create workout without training session
      const [workout] = await tx
        .insert(Workout)
        .values({
          userId: input.userId,
          businessId: input.businessId,
          createdByTrainerId: input.createdByTrainerId,
          notes: transformed.workout.description,
          workoutType: transformed.workout.workoutType,
          totalPlannedSets: transformed.workout.totalPlannedSets,
          llmOutput: transformed.workout.llmOutput,
          templateConfig: transformed.workout.templateConfig,
          context: input.context || "individual",
          // No trainingSessionId for individual workouts
        })
        .returning();
        
      if (!workout) {
        throw new Error('Failed to create workout');
      }
      
      // Create workout exercises
      if (transformed.exercises.length > 0) {
        const exerciseData = this.createExerciseRecords(
          workout.id, 
          transformed.exercises
        );
        
        if (exerciseData.length > 0) {
          await tx.insert(WorkoutExercise).values(exerciseData);
        }
      }
      
      return workout;
    });
    
    return result;
  }

  /**
   * Validate LLM output exercises against database
   */
  validateLLMOutput(
    llmOutput: LLMWorkoutOutput, 
    exerciseLookup: Map<string, any>
  ): { valid: boolean; warnings?: string[] } {
    const validation = validateExerciseLookup(llmOutput, exerciseLookup);
    if (!validation.valid) {
      logger.warn('Some exercises not found', validation.warnings);
    }
    return validation;
  }

  /**
   * Transform LLM output to database format
   */
  async transformOutput(
    llmOutput: LLMWorkoutOutput,
    exerciseLookup: Map<string, any>,
    workoutType: string,
    workoutName?: string,
    workoutDescription?: string,
    clientName?: string
  ): Promise<TransformedWorkout> {
    const result = await transformLLMOutputToDB(
      llmOutput,
      exerciseLookup,
      workoutType || 'standard',
      workoutName,
      workoutDescription || `Generated by AI for ${clientName || 'client'}`
    );
    
    // Ensure description and templateConfig are always defined
    return {
      workout: {
        ...result.workout,
        description: result.workout.description || `Generated by AI for ${clientName || 'client'}`,
        templateConfig: result.workout.templateConfig || {}
      },
      exercises: result.exercises
    };
  }

  /**
   * Create workout record
   */
  private createWorkoutRecord(
    input: SaveWorkoutInput,
    transformed: TransformedWorkout
  ) {
    return {
      trainingSessionId: input.trainingSessionId,
      userId: input.userId,
      businessId: input.businessId,
      createdByTrainerId: input.createdByTrainerId,
      completedAt: new Date(), // LLM-generated workouts are marked as completed
      notes: transformed.workout.description,
      workoutType: transformed.workout.workoutType,
      totalPlannedSets: transformed.workout.totalPlannedSets,
      llmOutput: transformed.workout.llmOutput,
      templateConfig: transformed.workout.templateConfig,
      context: "group" as const, // Has training session
    };
  }

  /**
   * Create workout exercise records
   */
  private createExerciseRecords(
    workoutId: string,
    transformedExercises: TransformedWorkout['exercises']
  ) {
    return transformedExercises
      .filter(ex => ex.exerciseId !== 'unknown') // Skip unknown exercises
      .map(ex => ({
        workoutId,
        exerciseId: ex.exerciseId,
        orderIndex: ex.orderIndex,
        setsCompleted: ex.sets,
        groupName: ex.groupName,
        // Store additional info in notes for now
        notes: [
          ex.reps && `Reps: ${ex.reps}`,
          ex.restPeriod && `Rest: ${ex.restPeriod}`,
          ex.notes
        ].filter(Boolean).join(' | ') || undefined,
      }));
  }

  /**
   * Save LLM-generated workout with exercises
   */
  async saveWorkout(
    input: SaveWorkoutInput,
    clientName?: string
  ) {
    // Create exercise lookup
    const exerciseLookup = await this.createExerciseLookup();
    
    // Validate exercises in LLM output
    this.validateLLMOutput(input.llmOutput, exerciseLookup);
    
    // Transform LLM output to database format
    const transformed = await this.transformOutput(
      input.llmOutput,
      exerciseLookup,
      input.workoutType || 'standard',
      input.workoutName,
      input.workoutDescription,
      clientName
    );
    
    // Use transaction to create workout and exercises atomically
    const result = await this.db.transaction(async (tx) => {
      // Create workout with transformed data
      const [workout] = await tx
        .insert(Workout)
        .values(this.createWorkoutRecord(input, transformed))
        .returning();
        
      if (!workout) {
        throw new Error('Failed to create workout');
      }
      
      // Create workout exercises with groupName
      if (transformed.exercises.length > 0) {
        const exerciseData = this.createExerciseRecords(
          workout.id, 
          transformed.exercises
        );
        
        if (exerciseData.length > 0) {
          await tx.insert(WorkoutExercise).values(exerciseData);
        }
      }
      
      return workout;
    });
    
    return result;
  }
}